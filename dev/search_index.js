var documenterSearchIndex = {"docs":
[{"location":"api.html","page":"API","title":"API","text":"CurrentModule = ODEHybrid ","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Pages = [\"api.md\"]","category":"page"},{"location":"api.html#API","page":"API","title":"API","text":"","category":"section"},{"location":"api.html","page":"API","title":"API","text":"This page is a dump of all the docstrings found in the code.","category":"page"},{"location":"api.html","page":"API","title":"API","text":"Modules = [ODEHybrid]\nOrder = [:module, :type, :function, :macro]","category":"page"},{"location":"api.html#ODEHybrid.ODE_SET","page":"API","title":"ODEHybrid.ODE_SET","text":"Copy of MATLAB's ODE SET struct\n\n\n\n\n\n","category":"type"},{"location":"api.html#ODEHybrid.TimeSeriesLogger","page":"API","title":"ODEHybrid.TimeSeriesLogger","text":"A struct for keeping track of numerous pieces of data over time throughout a process. It's designed to be easy to use and relatively quickly. It logs numeric types of any size (scalars, vectors, or matrices), as long as the size is consistent from sample to sample.\n\nExample:\n\nlog = TimeSeriesLogger();    # Make a new logger.\nx   = [0; 0];\nfor t = 1:100                # Make a random walk.\n    x = x + randn(2, 1);     # Take a single step.\n    add!(log, \"walk\", t, x); # Log a single sample, x, at time t.\nend\n\ntsl_plot(log)                # Plot everything.\n\n\n# We can also access specific logs by their names. In the above, we only\n#   have one log ('walk'). Let's get that log from the logger.\n\nt_log, x_log = get_log(log, \"walk\");    # Get a specific log.\nplot(x_log[:, 1], x_log[:, 2]);         # Do something with it.\n\n# We can make sure a log exists before trying to do anything with it:\n\nif contains(log,\"walk\")\n    x_log = get_log(log, \"walk\");\n    plot(x_log[:, 1], x_log[:, 2]);\n;\n\n# If we want to log something but don't want it plotted when we call\n#   |plot|, then we can pass in false to the logger when we add the signal.\n\nadd!(log, \"var1\", t, x, false);\n\n# To group items into different figures when they're plotted, give them\n#   \"groups\":\n\nadd!(log, \"var1\", t, x, true, \"group1\");\nadd!(log, \"var2\", t, y, true, \"group2\");\nadd!(log, \"foo\",  t, bar, true, \"group1\");\n\n# All of the items with common group names will be added to the same\n#   figures as subplots.\n\n# Finally, we can clear out the logger with |initialize|. This deletes all\n#   data and returns the logger to its initial state.\n\ninitialize!(log);\n\nMethods\n\n\n\ninitialize! Clear out all data.\nadd!        Add a single data point to a time series.\ncontains    See if a time series exists (by name).\nget_log     Return a log by name.\ntsl_plot    Plot the logged series.\n\nNotes\n\nTimeSeriesLogger was created as the logging mechanism for odehybrid. However, it's not dependent on that project and so can be used anywhere.\n\nTimeSeriesLogger is not related to the 'timeseries' class in MATLAB.\n\nSince this class never knows how much more data is going to be logged, it can't preallocate the appropriate amount of space. However, increasing the size of its data stores by one row every time a new sample is added is very slow. To combat this, the data store starts off small and doubles whenever the store is at capacity. Say we're logging a 4x1 signal. When the first sample is added (say it's log k), data{k}{2} will be 1x4. When the second signal is added, it becomes 2x4. For the third, it's 4x4, then 8x4, 16x4, etc. A separate counter stores how much of this allocated  space is currently used. This reduces the number of allocations from n to log2(n). Practically, it saves a little time during logging without too much complexity.\n\nOnline doc: http://www.anuncommonlab.com/doc/odehybrid/TimeSeriesLogger.html\n\nCopyright 2014 An Uncommon Lab\n\n\n\n\n\n","category":"type"},{"location":"api.html#ODEHybrid.add!","page":"API","title":"ODEHybrid.add!","text":"Add a new log or append to an existing log by name. Returns true iff a new log was created.\n\nadd!(log, \"var1\", t, x);\nadd!(log, \"var1\", t, x, true);  # Show log in plots (default)\nadd!(log, \"var1\", t, x, false); # Don't show log in plots\n\n# Signals can be grouped together into figures by given them\n#   a common group argument. Here, both var1 and var2 logs will\n#   be plotted together.\n\nadd!(log, \"var1\", t,  x, true, \"group1\");\nadd!(log, \"var2\", t2, y, true, \"group1\");\n\nNOTE that unlike in MATLAB, the signals are stored separately in times (t) and data (x), (e.g., the kth pair would be log.times[k] and log.data[k])\n\n\n\n\n\n","category":"function"},{"location":"api.html#ODEHybrid.contains-Tuple{TimeSeriesLogger, Any}","page":"API","title":"ODEHybrid.contains","text":"Return 'true' iff the TimeSeriesLogger contains this name \n\n\n\n\n\n","category":"method"},{"location":"api.html#ODEHybrid.get_log-Tuple{TimeSeriesLogger, Any}","page":"API","title":"ODEHybrid.get_log","text":"Return a specific log by name.\n\nIf one output is request, it returns the data. If two are  requested, it returns the time and the data. Returns empty if the logs don't exist (use the 'contains' function to test for this).\n\nExample:\n\nx = get_log(log, \"signal1\");\nt, x = get_log(log, \"signal1\");\n\nNOTE that |t| will be ns-by-1 and x will be ns-by-nx, where nx is the number of elements in a single sample.\n\n\n\n\n\n","category":"method"},{"location":"api.html#ODEHybrid.initialize!-Tuple{TimeSeriesLogger}","page":"API","title":"ODEHybrid.initialize!","text":"Clears out all fields in a Time Series Logger (in-place)\n\n\n\n\n\n","category":"method"},{"location":"api.html#ODEHybrid.interp1","page":"API","title":"ODEHybrid.interp1","text":"Simplified Interp1 (Ported from MATLAB), which returns interpolated values of a 1-D function at query points using linear interpolation. \n\nInputs:      x:  Vector containing sample points (in a tuple, pass in (x,) if needs be)     v:  Vector containing values corresponding to x      xq: Vector containing coordinates of the query points     options: (Optional) Interpolation method\n\nOutputs:     interp_vals:  Interpolated values at query points\n\n\n\n\n\n","category":"function"},{"location":"api.html#ODEHybrid.interpd-NTuple{4, Any}","page":"API","title":"ODEHybrid.interpd","text":"An interpolation function for time series which may have multiple values at a single timestep (e.g., discrete updates). It works like MATLAB's  built-in interp1.\n\nxi = interpd(t, x, ti); xi = interpd(t, x, ti, mode);\n\nInputs:\n\nt     Times  (n-by-1)\nx     States (n-by-m)\nti    Output times (p-by-1)\nmode  '-' for left-most values, '+' for right-most values (default)\n\n(NOTE that unlike the MATLAB version, no additional arguments can be passed in yet (e.g., 'nearest'))\n\nOutputs:\n\nxi  States corresponding to output times (p-by-m)\n\nExample:\n\n# Create some times and states. Note that there are two states at t=3.\n\nt = [2.76, 2.91, 3,   3,   3.12];\nx = [0.2,  0.3,  0.4, 1.1, 1.2];\n\n# Create the desired output times.\n\nti = (2.8:0.1:3.1);\n\n# Interpolate (t, x) linearly at ti, keeping the right-most values.\n\nxi = interpd(t, x, ti)\n\n# Interpolate (t, x) linearly at ti, keeping the left-most values.\n\nxi = interpd(t, x, ti, '-')\n\nSee also: examples_odehybrid.\n\nOnline doc: http://www.anuncommonlab.com/doc/odehybrid/interpd.html\n\nCopyright 2014 An Uncommon Lab\n\n\n\n\n\n","category":"method"},{"location":"api.html#ODEHybrid.odehybrid","page":"API","title":"ODEHybrid.odehybrid","text":"Hybrid continuous and discrete propagation.\n\nThis function propagates an ordinary differential equation along with a discrete update equation in a manner similar to MATLAB's ode45 function (which only propagates an ordinary differential equation). This is useful for implementing discrete-time controllers or simulating processes that are updated at discrete intervals.\n\nA large number of examples can be found in examples_odehybrid or by entering the following at the command line:\n\nhome = fileparts(which('examples_odehybrid'));\n\nweb(fullfile(home, 'html', 'examples_odehybrid.html'));\n\nInterfaces:\n\nt, yc, td, yd = odehybrid(solver, ode, de, \n                            dt, ts, yc0, yd0);\n\nt, yc1m, td, yd1n = odehybrid(solver, ode, de,\n                            dt, ts, [yc1, yc2m] [yd1, yd2n]);\n\nt, ..., td, ..., te, yc1m, yd1n, ie = odehybrid(solver, ode, de, \n                                                  dt, ts, yc0, yd0);\n\nsol = odehybrid(solver, ode, [de1, de2, ...], [dt1, dt2, ...], \n                    ts, yc0, yd0);\n\nsol = odehybrid(..., [options], [log]);\nsol = odehybrid(...);\n\nInputs:\n\nsolver  Continuous-time propagator to use, e.g. ODEHybrid.rkadapt\node     Ordinary differential equation to use with solver. The interface\n          should be fun(t, xc1, xc2, ..., xcm, xd1, xd2, ..., xdn) where\n          xc1, xc2, ..., xcm are the continuous states and xd1, xd2, ..., \n          xdn are the discrete states. It should return the derivatives of\n          the continuous states (m outputs).\nde      Discrete update equation(s) (either a function or cell\n          array of functions) with the same inputs as ode but\n          outputing the updated continuous and discrete states (n+m\n          outputs).\ndt      Time step(s) of discrete update equation(s). If de is an\n          array of multiple functions, this should be an array of the same\n          size.\nts      Time span, [t_start, t_end]\nyc0     Array of initial continuous states\nyd0     Array of initial discrete states\noptions (Optional) options structure from odeset\nlog     (Optional) TimeSeriesLogger for logging in the ode and de. If a\n          log is passed in, both ode and de *must* be able to accomodate\n          having a log input or not as the final argument. E.g., |ode|\n          will be called as: ode(t, xc1, ..., xd1, ..., xdn) and\n          ode(t, xc1, ..., xd1, ..., xdn, log).\n\nOutputs:\n\nt       Times corresponding to continuous states (nc-by-1)\nyc1m    Continuous state outputs (m outputs, each nc-by-1)\ntd      Times corresponding to discrete state updates (nd-by-1)\nyd1n    Discrete state outputs (n outputs, each nd-by-1)\nte      Times corresponding to events (ne-by-1)\nyce1m   Continuous states at events (m outputs, each ne-by-1)\nyde1n   Discrete states at events (n outputs, each ne-by-1)\nie      Index of triggering event. See documentation in odeset for more \n          on events.\nsol     If a single output is requested, it will be a structure with\n          fields for each of the individual outputs. The various\n          continuous states will be grouped in 'yc', the discrete into\n          'yd', the continuous states at events into 'yce', and the\n          discrete states at events into 'yde'.\n\n(NOTE that events are not currently supported!)\n\nExample:\n\n# This is a quick example of simulating an unstable continuous system with\n#   a stabilizing discrete-time controller.\n\node = (t, x, u) -> [0 1; 2 0] * x + [0; 1] * u;  # Differential equation\nde  = (t, x, u) -> (x, -[8 4] * x);              # Discrete update equation\ndt  = 0.1;                                       # Discrete eq. time step (float or float array)\nts  = [0 5];                                     # From 0 to 5s\nx0  = [1.0; 0.0];                                # Initial continuous state (floats, not Ints)\nu0  = 0;                                         # Initial discrete state\nt, x, tu, u = odehybrid(ODEHybrid.rkadapt, ode, de, dt, ts, x0, u0);    # Simulate!\n\nplot(t, x, xlabel = \"Time\", title = \"Example\", label = [\"x₁\" \"x₂\"])\nscatter!(tu, u, label = \"u\")\n\nSee also: examples_odehybrid, ode45, rkadapt, rkfixed.\n\nOnline doc: http://www.anuncommonlab.com/doc/odehybrid/odehybrid.html\n\nCopyright 2014 An Uncommon Lab\n\n\n\n\n\n","category":"function"},{"location":"api.html#ODEHybrid.rk4-Tuple{Any, Any, Any, ODE_SET}","page":"API","title":"ODEHybrid.rk4","text":"Runge-Kutta 4th order integration method.\n\nImplements numerical propagation of an ordinary differential equation from some initial value over the desired range. This function is similar to MATLAB's variable-step ODE propagators (e.g., ode45), but uses a fixed step method. This is useful either when one knows an appropriate  step size or when a process is interrupted frequently (ode45 and the similar functions in MATLAB will always make at least a certain number of steps between ts(1) and ts(2), which may be very many more than are necessary).\n\nt, x = rk4(ode, ts, x0, options);\n\nInputs:\n\node     Ordinary differential equation function\nts      Time span, [t_start, t_end]\nx0      Initial state (column vector)\noptions One can specify an options structure instead of dt\n        so that this function is compatible with ode45 and its ilk. The\n        only valid fields are MaxStep (the time step) and OutputFcn\n        (if dt is passed in rather than options, an empty ODE_SET is initialized\n        with the provided time step dt)\n\nOutputs:\n\nt       Time history\nx       State history, with each row containing the state corresponding to\n            the time in the same row of t.\n\nExample:\n\n# Simulate an undamped harmonic oscillator for 10s with a 0.1s time\n#     step, starting from an initial state of [1; 0]:\n\node = (t, x) -> [-x[2]; x[1]]\nt, x = rk4(ode, [0 10], [1; 0], 0.1);\nplot(t, x);\n\nSee also: odehybrid, ode45, odeset, rkfixed, rkadapt.\n\nOnline doc: http://www.anuncommonlab.com/doc/odehybrid/rk4.html\n\nCopyright 2014 An Uncommon Lab\n\n\n\n\n\n","category":"method"},{"location":"api.html#ODEHybrid.rkadapt-Tuple{Any, Any, Any, ODE_SET, Any, Any, Any, Any}","page":"API","title":"ODEHybrid.rkadapt","text":"Runge-Kutta adaptive-step integration using the specified weights, nodes, and Runge-Kutta matrix (or Dormand-Prince 5(4) by default).\n\nImplements numerical propagation of an ordinary differential equation from some initial value over the desired range. This function is similar to MATLAB's variable-step ODE propagators (e.g., ode45), but is  generalized to any Butcher tableau. Unlike ode45, however, there's no inherent minimum number of steps that this function will take; if it can finish integration with a single step, it will, whereas ode45 will always take at least a certain number of steps, no matter how small the time interval and how smooth the dynamics. Therefore, this function is commonly more useful with odehybrid than ode45.\n\nThis function is generic for all adaptive-step Runge-Kutta methods. That is, any adaptive-step Runge-Kutta propagator can be created by passing the weightes, nodes, and Runge-Kutta matrix (together, the Butcher  tableau) into this function. It will correctly take advantage of the  first-same-as-last property, eliminating one function evaluation per  step when the table has this property. See the examples below.\n\nt, x = rk4adapt(ode, ts, x0);\nt, x = rk4adapt(ode, ts, x0, options);\nt, x = rk4adapt(ode, ts, x0, a, b, c p);\nt, x = rk4adapt(ode, ts, x0, options, a, b, c, p);\n\nInputs:\n\node     Ordinary differential equation function (s.t. ẋ = ode(t, x);)\nts      Time span, [t_start, t_end]\nx0      Initial state (column vector)\noptions Options structure from odeset. This function uses the\n            InitialStep, MaxStep, OutputFcn, RelTol, and AbsTol fields only.\na       Runge-Kutta matrix (s-by-s)\nb       Weights (2-by-s), the top row containing the weights for the \n            state update\nc       Nodes (s-by-1)\np       Lowest order method represented by b (e.g., for\n            Runge-Kutta-Fehlberg, this is 4).\n\n(NOTE that if a/b/c/p are not specified, this defaults to Dormand-Prince)\n\nOutputs:\n\nt       Time history\nx       State history, with each row containing the state corresponding to\n            the time in the same row of t.\n\nExample:\n\n# Simulate an undamped harmonic oscillator for 10s starting from an \n#    initial state of [1; 0] using the default a, b, c, and p\n#    (Dormand-Prince 5(4)):\n\nt, x = rkadapt((t,x) -> [-x[2]; x[1]], [0 10], [1; 0]);\nplot(t, x);\n\n\n# Add options.\n\noptions = ODE_SET(MaxStep = 0.1, InitialStep = 0.05)\nt, x = rkadapt( (t, x) -> [-x[2]; x[1]], [0 10], [1; 0], options)\nplot(t, x);\n\n\n# Now simulate with Bogacki-Shampine 3(2).\n\na = [  0    0    0    0; \n       1/2  0    0    0; \n       0    3/4  0    0; \n       2/9  1/3  4/9  0];\n\nb = [ 2/9   1/3  4/9  0;       # For the update\n      7/24  1/4  1/3  1/8];    # For the error prediction\n\nc = [ 0     1/2  3/4  1];\n\np = 2;                         # The lower of the two orders\n\nt, x = rkadapt( (t,x) -> [-x[2]; x[1]], [0 10], [1; 0], a, b, c, p);\nplot(t, x);\n\nSee \"Runge-Kutta methods\" on Wikipedia for discussion of the Butcher tableau (a, b, and c).\n\nReference: \n\nDormand, J. R., and P. J. Prince. \"A family of embedded Ruge-Kutta formulae.\" Journal of Computational and Applied Mathematics 6.1 (1980): 19-26. Web. 22 Apr. 2014.\n\nSee also: odehybrid, ode45, odeset, rkfixed.\n\nOnline doc: http://www.anuncommonlab.com/doc/odehybrid/rkadapt.html\n\nCopyright 2014 An Uncommon Lab\n\n\n\n\n\n","category":"method"},{"location":"api.html#ODEHybrid.rkfixed-Tuple{Any, Any, Any, ODE_SET, Any, Any, Any}","page":"API","title":"ODEHybrid.rkfixed","text":"Runge-Kutta fixed-step integration using the specified weights, nodes, and Runge-Kutta matrix (or the Runge-Kutta 4th order \"3/8\" method by default).\n\nImplements numerical propagation of an ordinary differential equation from some initial value over the desired range. This function is similar to MATLAB's variable-step ODE propagators (e.g., ode45), but uses a fixed step method. This is useful either when one knows an appropriate  step size or when a process is interrupted frequently (ode45 and the similar functions in MATLAB will always make at least a certain number of steps between ts(1) and ts(2), which may be very many more than are necessary).\n\nThis function is generic for all fixed-step Runge-Kutta methods. That is, any fixed-step Runge-Kutta propagator can be created by passing the weightes, nodes, and Runge-Kutta matrix (together, the Butcher tableau)  into this function. See the example below.\n\nt, x = rkfixed(ode, ts, x0, dt);\nt, x = rkfixed(ode, ts, x0, dt, a, b, c);\nt, x = rkfixed(ode, ts, x0, options);\nt, x = rkfixed(ode, ts, x0, options, a, b, c);\n\nInputs:\n\node     Ordinary differential equation function\nts      Time span, [t_start, t_end]\nx0      Initial state (column vector)\noptions One can specify an options structure instead of dt      \n            so that this function is compatible with ode45 and its ilk. The\n            only valid fields are MaxStep (the time step) and OutputFcn\na       Runge-Kutta matrix\nb       Weights\nc       Nodes\n\nOutputs:\n\nt       Time history\nx       State history, with each row containing the state corresponding to\n            the time in the same row of t.\n\nExample:\n\n# Simulate an undamped harmonic oscillator for 10s with a 0.1s time\n#    step, starting from an initial state of [1; 0] using RK 4th order\n#    integration (via the Butcher tableau specified by a, b, and c). This\n#    is exactly the same as the rk4 function\n\na = [ 0    0    0  0; \n      0.5  0    0  0; \n      0    0.5  0  0; \n      0    0    1  0];\n\nb = [ 1  2  2  1]/6;\nc = [ 0  0.5  0.5  1];\n\nt, x = rkfixed( (t,x) -> [-x[2]; x[1]], [0 10], [1; 0], 0.1, a, b, c);\nplot(t, x);\n\nSee \"Runge-Kutta methods\" on Wikipedia for discussion of the Butcher tableau (a, b, and c).\n\nSee also: odehybrid, ode45, odeset, rk4.\n\nOnline doc: http://www.anuncommonlab.com/doc/odehybrid/rkfixed.html\n\nCopyright 2014 An Uncommon Lab\n\n\n\n\n\n","category":"method"},{"location":"api.html#ODEHybrid.state_to_vector-Tuple{Any}","page":"API","title":"ODEHybrid.state_to_vector","text":"Build a state vector by recursively moving through the elements of a more complex state (matrix, cell array, or struct), saving the numerical  values along the way in a vector. This is used in odehybrid to convert a complex series of states into a vector to be used for continuous state updates. The reverse function is vectortostate.\n\nvector = statetovector(state);\n\nInputs:\n\nstate:   A numeric, array, or struct array type, the contents of\n            which consist of numeric, array, or struct array types, etc.\n            (Structs MUST be mutable)\n\nOutputs:\n\nvector:  A vector containing the numerical values from the state (doubles)\n\nExample:\n\nmutable struct TestStruc\n    a\n    bcd\nend\nBase.:(==)(a::TestStruc, b::TestStruc) = (Base.:(==)(a.a, b.a) && Base.:(==)(a.bcd, b.bcd)) # Custom\n\nx = [ [1 3; 4 2], TestStruc([5; 6], [7:9; 10]),  3.14 ]\nv = state_to_vector(x)\nx2 = vector_to_state(v, x)\nx .== x2[1]\n\nSee also: vectortostate.\n\nOnline doc: http://www.anuncommonlab.com/doc/odehybrid/statetovector.html\n\nCopyright 2014 An Uncommon Lab\n\n\n\n\n\n","category":"method"},{"location":"api.html#ODEHybrid.tsl_plot-Tuple{TimeSeriesLogger, Any}","page":"API","title":"ODEHybrid.tsl_plot","text":"Plot all of the signals, grouped appropriately into figures. A custom x label can be added to figures as well\n\n\n\n\n\n","category":"method"},{"location":"api.html#ODEHybrid.vec_to_mat-Tuple{Any}","page":"API","title":"ODEHybrid.vec_to_mat","text":"Helper function that converts a N-element vector with each element of length M into an N x M matrix \n\n\n\n\n\n","category":"method"},{"location":"api.html#ODEHybrid.vector_to_state-Tuple{Any, Any}","page":"API","title":"ODEHybrid.vector_to_state","text":"Build a state from a state vector by recursively moving through the  elements of a more complex example state (matrix, cell array, or struct), placing the relevant numerical values from the vector into the  appropriate places. This is used in odehybrid to convert a state vector into the original complex setup of states. The reverse function is statetovector.\n\nstate = vectortostate(vector, state);\n\nInputs:\n\nvector  A vector containing the numerical values from the object\nstate   A numeric, cell array, or struct array type representing the\n        sizes and types for the values in vector\n\nOutputs:\n\nstate   A numeric, cell array, or struct array type\ncount   (Internal use only)\n\nExample:\n\nmutable struct TestStruc\n    a\n    bcd\nend\nBase.:(==)(a::TestStruc, b::TestStruc) = (Base.:(==)(a.a, b.a) && Base.:(==)(a.bcd, b.bcd)) # Custom\n\nx = [ [1 3; 4 2], TestStruc([5; 6], [7:9; 10]),  3.14 ]\nv = state_to_vector(x)\nx2 = vector_to_state(v, x)\nx .== x2[1]\n\nSee also: statetovector.\n\nOnline doc: http://www.anuncommonlab.com/doc/odehybrid/vectortostate.html\n\nCopyright 2014 An Uncommon Lab\n\n\n\n\n\n","category":"method"},{"location":"index.html#ODEHybrid.jl","page":"Introduction","title":"ODEHybrid.jl","text":"","category":"section"},{"location":"index.html#Overview","page":"Introduction","title":"Overview","text":"","category":"section"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"This is a Julia implementation of the ODE Hybrid package made for MATLAB. This ported version tries to follow the MATLAB implementation closely so as to maintain the same functionality and match the MATLAB output ","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"(NOTE that because the original code does not allow for Events to be used for the custom RK functions,  relying instead on the ODE suite of solvers in MATLAB like ODE45, Events are currently not supported).","category":"page"},{"location":"index.html","page":"Introduction","title":"Introduction","text":"The original package is well-documented at http://www.anuncommonlab.com/doc/odehybrid ","category":"page"}]
}
