<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ODEHybrid.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">ODEHybrid.jl</a></span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="api.html">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="api.html">API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="api.html">API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/benjjensen/ODEHybrid.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><ul><li><a href="api.html#API">API</a></li></ul><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><p>This page is a dump of all the docstrings found in the code.</p><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.ODE_SET" href="#ODEHybrid.ODE_SET"><code>ODEHybrid.ODE_SET</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Copy of MATLAB&#39;s ODE SET struct</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/ODEHybrid.jl#L6-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.TimeSeriesLogger" href="#ODEHybrid.TimeSeriesLogger"><code>ODEHybrid.TimeSeriesLogger</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A struct for keeping track of numerous pieces of data over time throughout a process. It&#39;s designed to be easy to use and relatively quickly. It logs numeric types of any size (scalars, vectors, or matrices), as long as the size is consistent from sample to sample.</p><p>Example:</p><pre><code class="nohighlight hljs">log = TimeSeriesLogger();    # Make a new logger.
x   = [0; 0];
for t = 1:100                # Make a random walk.
    x = x + randn(2, 1);     # Take a single step.
    add!(log, &quot;walk&quot;, t, x); # Log a single sample, x, at time t.
end

tsl_plot(log)                # Plot everything.


# We can also access specific logs by their names. In the above, we only
#   have one log (&#39;walk&#39;). Let&#39;s get that log from the logger.

t_log, x_log = get_log(log, &quot;walk&quot;);    # Get a specific log.
plot(x_log[:, 1], x_log[:, 2]);         # Do something with it.

# We can make sure a log exists before trying to do anything with it:

if contains(log,&quot;walk&quot;)
    x_log = get_log(log, &quot;walk&quot;);
    plot(x_log[:, 1], x_log[:, 2]);
;

# If we want to log something but don&#39;t want it plotted when we call
#   |plot|, then we can pass in false to the logger when we add the signal.

add!(log, &quot;var1&quot;, t, x, false);

# To group items into different figures when they&#39;re plotted, give them
#   &quot;groups&quot;:

add!(log, &quot;var1&quot;, t, x, true, &quot;group1&quot;);
add!(log, &quot;var2&quot;, t, y, true, &quot;group2&quot;);
add!(log, &quot;foo&quot;,  t, bar, true, &quot;group1&quot;);

# All of the items with common group names will be added to the same
#   figures as subplots.

# Finally, we can clear out the logger with |initialize|. This deletes all
#   data and returns the logger to its initial state.

initialize!(log);</code></pre><p><strong>Methods</strong></p><hr/><ul><li>initialize! Clear out all data.</li><li>add!        Add a single data point to a time series.</li><li>contains    See if a time series exists (by name).</li><li>get_log     Return a log by name.</li><li>tsl_plot    Plot the logged series.</li></ul><p><strong>Notes</strong></p><p>TimeSeriesLogger was created as the logging mechanism for odehybrid. However, it&#39;s not dependent on that project and so can be used anywhere.</p><p>TimeSeriesLogger is not related to the &#39;timeseries&#39; class in MATLAB.</p><p>Since this class never knows how much more data is going to be logged, it can&#39;t preallocate the appropriate amount of space. However, increasing the size of its data stores by one row every time a new sample is added is very slow. To combat this, the data store starts off small and doubles whenever the store is at capacity. Say we&#39;re logging a 4x1 signal. When the first sample is added (say it&#39;s log k), data{k}{2} will be 1x4. When the second signal is added, it becomes 2x4. For the third, it&#39;s 4x4, then 8x4, 16x4, etc. A separate counter stores how much of this allocated  space is currently used. This reduces the number of allocations from n to log2(n). Practically, it saves a little time during logging without too much complexity.</p><p>Online doc: http://www.anuncommonlab.com/doc/odehybrid/TimeSeriesLogger.html</p><p>Copyright 2014 An Uncommon Lab</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/TimeSeriesLogger.jl#L3-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.add!" href="#ODEHybrid.add!"><code>ODEHybrid.add!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Add a new log or append to an existing log by name. Returns true iff a new log was created.</p><pre><code class="nohighlight hljs">add!(log, &quot;var1&quot;, t, x);
add!(log, &quot;var1&quot;, t, x, true);  # Show log in plots (default)
add!(log, &quot;var1&quot;, t, x, false); # Don&#39;t show log in plots

# Signals can be grouped together into figures by given them
#   a common group argument. Here, both var1 and var2 logs will
#   be plotted together.

add!(log, &quot;var1&quot;, t,  x, true, &quot;group1&quot;);
add!(log, &quot;var2&quot;, t2, y, true, &quot;group1&quot;);</code></pre><p>NOTE that unlike in MATLAB, the signals are stored separately in times (t) and data (x), (e.g., the kth pair would be log.times[k] and log.data[k])</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/TimeSeriesLogger.jl#L102-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.contains-Tuple{TimeSeriesLogger, Any}" href="#ODEHybrid.contains-Tuple{TimeSeriesLogger, Any}"><code>ODEHybrid.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return &#39;true&#39; iff the TimeSeriesLogger contains this name </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/TimeSeriesLogger.jl#L183-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.get_log-Tuple{TimeSeriesLogger, Any}" href="#ODEHybrid.get_log-Tuple{TimeSeriesLogger, Any}"><code>ODEHybrid.get_log</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a specific log by name.</p><p>If one output is request, it returns the data. If two are  requested, it returns the time and the data. Returns empty if the logs don&#39;t exist (use the &#39;contains&#39; function to test for this).</p><p>Example:</p><pre><code class="nohighlight hljs">x = get_log(log, &quot;signal1&quot;);
t, x = get_log(log, &quot;signal1&quot;);</code></pre><p>NOTE that |t| will be ns-by-1 and x will be ns-by-nx, where nx is the number of elements in a single sample.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/TimeSeriesLogger.jl#L193-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.initialize!-Tuple{TimeSeriesLogger}" href="#ODEHybrid.initialize!-Tuple{TimeSeriesLogger}"><code>ODEHybrid.initialize!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Clears out all fields in a Time Series Logger (in-place)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/TimeSeriesLogger.jl#L224-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.interp1" href="#ODEHybrid.interp1"><code>ODEHybrid.interp1</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Simplified Interp1 (Ported from MATLAB), which returns interpolated values of a 1-D function at query points using linear interpolation. </p><p>Inputs:      x:  Vector containing sample points (in a tuple, pass in (x,) if needs be)     v:  Vector containing values corresponding to x      xq: Vector containing coordinates of the query points     options: (Optional) Interpolation method</p><p>Outputs:     interp_vals:  Interpolated values at query points</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/interpd.jl#L156-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.interpd-NTuple{4, Any}" href="#ODEHybrid.interpd-NTuple{4, Any}"><code>ODEHybrid.interpd</code></a> — <span class="docstring-category">Method</span></header><section><div><p>An interpolation function for time series which may have multiple values at a single timestep (e.g., discrete updates). It works like MATLAB&#39;s  built-in interp1.</p><p>xi = interpd(t, x, ti); xi = interpd(t, x, ti, mode);</p><p>Inputs:</p><pre><code class="nohighlight hljs">t     Times  (n-by-1)
x     States (n-by-m)
ti    Output times (p-by-1)
mode  &#39;-&#39; for left-most values, &#39;+&#39; for right-most values (default)

(NOTE that unlike the MATLAB version, no additional arguments can be passed in yet (e.g., &#39;nearest&#39;))</code></pre><p>Outputs:</p><pre><code class="nohighlight hljs">xi  States corresponding to output times (p-by-m)</code></pre><p>Example:</p><pre><code class="nohighlight hljs"># Create some times and states. Note that there are two states at t=3.

t = [2.76, 2.91, 3,   3,   3.12];
x = [0.2,  0.3,  0.4, 1.1, 1.2];

# Create the desired output times.

ti = (2.8:0.1:3.1);

# Interpolate (t, x) linearly at ti, keeping the right-most values.

xi = interpd(t, x, ti)

# Interpolate (t, x) linearly at ti, keeping the left-most values.

xi = interpd(t, x, ti, &#39;-&#39;)</code></pre><p>See also: examples_odehybrid.</p><p>Online doc: http://www.anuncommonlab.com/doc/odehybrid/interpd.html</p><p>Copyright 2014 An Uncommon Lab</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/interpd.jl#L5-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.odehybrid" href="#ODEHybrid.odehybrid"><code>ODEHybrid.odehybrid</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Hybrid continuous and discrete propagation.</p><p>This function propagates an ordinary differential equation along with a discrete update equation in a manner similar to MATLAB&#39;s ode45 function (which only propagates an ordinary differential equation). This is useful for implementing discrete-time controllers or simulating processes that are updated at discrete intervals.</p><p>A large number of examples can be found in examples_odehybrid or by entering the following at the command line:</p><p><strong>home = fileparts(which(&#39;examples_odehybrid&#39;));</strong></p><p><strong>web(fullfile(home, &#39;html&#39;, &#39;examples_odehybrid.html&#39;));</strong></p><p>Interfaces:</p><pre><code class="nohighlight hljs">t, yc, td, yd = odehybrid(solver, ode, de, 
                            dt, ts, yc0, yd0);

t, yc1m, td, yd1n = odehybrid(solver, ode, de,
                            dt, ts, [yc1, yc2m] [yd1, yd2n]);

t, ..., td, ..., te, yc1m, yd1n, ie = odehybrid(solver, ode, de, 
                                                  dt, ts, yc0, yd0);

sol = odehybrid(solver, ode, [de1, de2, ...], [dt1, dt2, ...], 
                    ts, yc0, yd0);

sol = odehybrid(..., [options], [log]);
sol = odehybrid(...);</code></pre><p>Inputs:</p><pre><code class="nohighlight hljs">solver  Continuous-time propagator to use, e.g. ODEHybrid.rkadapt
ode     Ordinary differential equation to use with solver. The interface
          should be fun(t, xc1, xc2, ..., xcm, xd1, xd2, ..., xdn) where
          xc1, xc2, ..., xcm are the continuous states and xd1, xd2, ..., 
          xdn are the discrete states. It should return the derivatives of
          the continuous states (m outputs).
de      Discrete update equation(s) (either a function or cell
          array of functions) with the same inputs as ode but
          outputing the updated continuous and discrete states (n+m
          outputs).
dt      Time step(s) of discrete update equation(s). If de is an
          array of multiple functions, this should be an array of the same
          size.
ts      Time span, [t_start, t_end]
yc0     Array of initial continuous states
yd0     Array of initial discrete states
options (Optional) options structure from odeset
log     (Optional) TimeSeriesLogger for logging in the ode and de. If a
          log is passed in, both ode and de *must* be able to accomodate
          having a log input or not as the final argument. E.g., |ode|
          will be called as: ode(t, xc1, ..., xd1, ..., xdn) and
          ode(t, xc1, ..., xd1, ..., xdn, log).</code></pre><p>Outputs:</p><pre><code class="nohighlight hljs">t       Times corresponding to continuous states (nc-by-1)
yc1m    Continuous state outputs (m outputs, each nc-by-1)
td      Times corresponding to discrete state updates (nd-by-1)
yd1n    Discrete state outputs (n outputs, each nd-by-1)
te      Times corresponding to events (ne-by-1)
yce1m   Continuous states at events (m outputs, each ne-by-1)
yde1n   Discrete states at events (n outputs, each ne-by-1)
ie      Index of triggering event. See documentation in odeset for more 
          on events.
sol     If a single output is requested, it will be a structure with
          fields for each of the individual outputs. The various
          continuous states will be grouped in &#39;yc&#39;, the discrete into
          &#39;yd&#39;, the continuous states at events into &#39;yce&#39;, and the
          discrete states at events into &#39;yde&#39;.

(NOTE that events are not currently supported!)</code></pre><p>Example:</p><pre><code class="nohighlight hljs"># This is a quick example of simulating an unstable continuous system with
#   a stabilizing discrete-time controller.

ode = (t, x, u) -&gt; [0 1; 2 0] * x + [0; 1] * u;  # Differential equation
de  = (t, x, u) -&gt; (x, -[8 4] * x);              # Discrete update equation
dt  = 0.1;                                       # Discrete eq. time step (float or float array)
ts  = [0 5];                                     # From 0 to 5s
x0  = [1.0; 0.0];                                # Initial continuous state (floats, not Ints)
u0  = 0;                                         # Initial discrete state
t, x, tu, u = odehybrid(ODEHybrid.rkadapt, ode, de, dt, ts, x0, u0);    # Simulate!

plot(t, x, xlabel = &quot;Time&quot;, title = &quot;Example&quot;, label = [&quot;x₁&quot; &quot;x₂&quot;])
scatter!(tu, u, label = &quot;u&quot;)</code></pre><p>See also: examples_odehybrid, ode45, rkadapt, rkfixed.</p><p>Online doc: http://www.anuncommonlab.com/doc/odehybrid/odehybrid.html</p><p>Copyright 2014 An Uncommon Lab</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/ODEHybrid.jl#L45-L143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.rk4-Tuple{Any, Any, Any, ODE_SET}" href="#ODEHybrid.rk4-Tuple{Any, Any, Any, ODE_SET}"><code>ODEHybrid.rk4</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Runge-Kutta 4th order integration method.</p><p>Implements numerical propagation of an ordinary differential equation from some initial value over the desired range. This function is similar to MATLAB&#39;s variable-step ODE propagators (e.g., ode45), but uses a fixed step method. This is useful either when one knows an appropriate  step size or when a process is interrupted frequently (ode45 and the similar functions in MATLAB will always make at least a certain number of steps between ts(1) and ts(2), which may be very many more than are necessary).</p><pre><code class="nohighlight hljs">t, x = rk4(ode, ts, x0, options);</code></pre><p>Inputs:</p><pre><code class="nohighlight hljs">ode     Ordinary differential equation function
ts      Time span, [t_start, t_end]
x0      Initial state (column vector)
options One can specify an options structure instead of dt
        so that this function is compatible with ode45 and its ilk. The
        only valid fields are MaxStep (the time step) and OutputFcn
        (if dt is passed in rather than options, an empty ODE_SET is initialized
        with the provided time step dt)</code></pre><p>Outputs:</p><pre><code class="nohighlight hljs">t       Time history
x       State history, with each row containing the state corresponding to
            the time in the same row of t.</code></pre><p>Example:</p><pre><code class="nohighlight hljs"># Simulate an undamped harmonic oscillator for 10s with a 0.1s time
#     step, starting from an initial state of [1; 0]:

ode = (t, x) -&gt; [-x[2]; x[1]]
t, x = rk4(ode, [0 10], [1; 0], 0.1);
plot(t, x);</code></pre><p>See also: odehybrid, ode45, odeset, rkfixed, rkadapt.</p><p>Online doc: http://www.anuncommonlab.com/doc/odehybrid/rk4.html</p><p>Copyright 2014 An Uncommon Lab</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/rk4.jl#L3-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.rkadapt-Tuple{Any, Any, Any, ODE_SET, Any, Any, Any, Any}" href="#ODEHybrid.rkadapt-Tuple{Any, Any, Any, ODE_SET, Any, Any, Any, Any}"><code>ODEHybrid.rkadapt</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Runge-Kutta adaptive-step integration using the specified weights, nodes, and Runge-Kutta matrix (or Dormand-Prince 5(4) by default).</p><p>Implements numerical propagation of an ordinary differential equation from some initial value over the desired range. This function is similar to MATLAB&#39;s variable-step ODE propagators (e.g., ode45), but is  generalized to any Butcher tableau. Unlike ode45, however, there&#39;s no inherent minimum number of steps that this function will take; if it can finish integration with a single step, it will, whereas ode45 will always take at least a certain number of steps, no matter how small the time interval and how smooth the dynamics. Therefore, this function is commonly more useful with odehybrid than ode45.</p><p>This function is generic for all adaptive-step Runge-Kutta methods. That is, any adaptive-step Runge-Kutta propagator can be created by passing the weightes, nodes, and Runge-Kutta matrix (together, the Butcher  tableau) into this function. It will correctly take advantage of the  first-same-as-last property, eliminating one function evaluation per  step when the table has this property. See the examples below.</p><pre><code class="nohighlight hljs">t, x = rk4adapt(ode, ts, x0);
t, x = rk4adapt(ode, ts, x0, options);
t, x = rk4adapt(ode, ts, x0, a, b, c p);
t, x = rk4adapt(ode, ts, x0, options, a, b, c, p);</code></pre><p>Inputs:</p><pre><code class="nohighlight hljs">ode     Ordinary differential equation function (s.t. ẋ = ode(t, x);)
ts      Time span, [t_start, t_end]
x0      Initial state (column vector)
options Options structure from odeset. This function uses the
            InitialStep, MaxStep, OutputFcn, RelTol, and AbsTol fields only.
a       Runge-Kutta matrix (s-by-s)
b       Weights (2-by-s), the top row containing the weights for the 
            state update
c       Nodes (s-by-1)
p       Lowest order method represented by b (e.g., for
            Runge-Kutta-Fehlberg, this is 4).

(NOTE that if a/b/c/p are not specified, this defaults to Dormand-Prince)</code></pre><p>Outputs:</p><pre><code class="nohighlight hljs">t       Time history
x       State history, with each row containing the state corresponding to
            the time in the same row of t.</code></pre><p>Example:</p><pre><code class="nohighlight hljs"># Simulate an undamped harmonic oscillator for 10s starting from an 
#    initial state of [1; 0] using the default a, b, c, and p
#    (Dormand-Prince 5(4)):

t, x = rkadapt((t,x) -&gt; [-x[2]; x[1]], [0 10], [1; 0]);
plot(t, x);


# Add options.

options = ODE_SET(MaxStep = 0.1, InitialStep = 0.05)
t, x = rkadapt( (t, x) -&gt; [-x[2]; x[1]], [0 10], [1; 0], options)
plot(t, x);


# Now simulate with Bogacki-Shampine 3(2).

a = [  0    0    0    0; 
       1/2  0    0    0; 
       0    3/4  0    0; 
       2/9  1/3  4/9  0];

b = [ 2/9   1/3  4/9  0;       # For the update
      7/24  1/4  1/3  1/8];    # For the error prediction

c = [ 0     1/2  3/4  1];

p = 2;                         # The lower of the two orders

t, x = rkadapt( (t,x) -&gt; [-x[2]; x[1]], [0 10], [1; 0], a, b, c, p);
plot(t, x);</code></pre><p>See &quot;Runge-Kutta methods&quot; on Wikipedia for discussion of the Butcher tableau (a, b, and c).</p><p>Reference: </p><p>Dormand, J. R., and P. J. Prince. &quot;A family of embedded Ruge-Kutta formulae.&quot; <em>Journal of Computational and Applied Mathematics</em> 6.1 (1980): 19-26. Web. 22 Apr. 2014.</p><p>See also: odehybrid, ode45, odeset, rkfixed.</p><p>Online doc: http://www.anuncommonlab.com/doc/odehybrid/rkadapt.html</p><p>Copyright 2014 An Uncommon Lab</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/rkadapt.jl#L3-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.rkfixed-Tuple{Any, Any, Any, ODE_SET, Any, Any, Any}" href="#ODEHybrid.rkfixed-Tuple{Any, Any, Any, ODE_SET, Any, Any, Any}"><code>ODEHybrid.rkfixed</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Runge-Kutta fixed-step integration using the specified weights, nodes, and Runge-Kutta matrix (or the Runge-Kutta 4th order &quot;3/8&quot; method by default).</p><p>Implements numerical propagation of an ordinary differential equation from some initial value over the desired range. This function is similar to MATLAB&#39;s variable-step ODE propagators (e.g., ode45), but uses a fixed step method. This is useful either when one knows an appropriate  step size or when a process is interrupted frequently (ode45 and the similar functions in MATLAB will always make at least a certain number of steps between ts(1) and ts(2), which may be very many more than are necessary).</p><p>This function is generic for all fixed-step Runge-Kutta methods. That is, any fixed-step Runge-Kutta propagator can be created by passing the weightes, nodes, and Runge-Kutta matrix (together, the Butcher tableau)  into this function. See the example below.</p><pre><code class="nohighlight hljs">t, x = rkfixed(ode, ts, x0, dt);
t, x = rkfixed(ode, ts, x0, dt, a, b, c);
t, x = rkfixed(ode, ts, x0, options);
t, x = rkfixed(ode, ts, x0, options, a, b, c);</code></pre><p>Inputs:</p><pre><code class="nohighlight hljs">ode     Ordinary differential equation function
ts      Time span, [t_start, t_end]
x0      Initial state (column vector)
options One can specify an options structure instead of dt      
            so that this function is compatible with ode45 and its ilk. The
            only valid fields are MaxStep (the time step) and OutputFcn
a       Runge-Kutta matrix
b       Weights
c       Nodes</code></pre><p>Outputs:</p><pre><code class="nohighlight hljs">t       Time history
x       State history, with each row containing the state corresponding to
            the time in the same row of t.</code></pre><p>Example:</p><pre><code class="nohighlight hljs"># Simulate an undamped harmonic oscillator for 10s with a 0.1s time
#    step, starting from an initial state of [1; 0] using RK 4th order
#    integration (via the Butcher tableau specified by a, b, and c). This
#    is exactly the same as the rk4 function

a = [ 0    0    0  0; 
      0.5  0    0  0; 
      0    0.5  0  0; 
      0    0    1  0];

b = [ 1  2  2  1]/6;
c = [ 0  0.5  0.5  1];

t, x = rkfixed( (t,x) -&gt; [-x[2]; x[1]], [0 10], [1; 0], 0.1, a, b, c);
plot(t, x);</code></pre><p>See &quot;Runge-Kutta methods&quot; on Wikipedia for discussion of the Butcher tableau (a, b, and c).</p><p>See also: odehybrid, ode45, odeset, rk4.</p><p>Online doc: http://www.anuncommonlab.com/doc/odehybrid/rkfixed.html</p><p>Copyright 2014 An Uncommon Lab</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/rkfixed.jl#L3-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.state_to_vector-Tuple{Any}" href="#ODEHybrid.state_to_vector-Tuple{Any}"><code>ODEHybrid.state_to_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build a state vector by recursively moving through the elements of a more complex state (matrix, cell array, or struct), saving the numerical  values along the way in a vector. This is used in odehybrid to convert a complex series of states into a vector to be used for continuous state updates. The reverse function is vector<em>to</em>state.</p><p>vector = state<em>to</em>vector(state);</p><p>Inputs:</p><pre><code class="nohighlight hljs">state:   A numeric, array, or struct array type, the contents of
            which consist of numeric, array, or struct array types, etc.
            (Structs MUST be mutable)</code></pre><p>Outputs:</p><pre><code class="nohighlight hljs">vector:  A vector containing the numerical values from the state (doubles)</code></pre><p>Example:</p><pre><code class="nohighlight hljs">mutable struct TestStruc
    a
    bcd
end
Base.:(==)(a::TestStruc, b::TestStruc) = (Base.:(==)(a.a, b.a) &amp;&amp; Base.:(==)(a.bcd, b.bcd)) # Custom

x = [ [1 3; 4 2], TestStruc([5; 6], [7:9; 10]),  3.14 ]
v = state_to_vector(x)
x2 = vector_to_state(v, x)
x .== x2[1]</code></pre><p>See also: vector<em>to</em>state.</p><p>Online doc: http://www.anuncommonlab.com/doc/odehybrid/state<em>to</em>vector.html</p><p>Copyright 2014 An Uncommon Lab</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/state_to_vector.jl#L3-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.tsl_plot-Tuple{TimeSeriesLogger, Any}" href="#ODEHybrid.tsl_plot-Tuple{TimeSeriesLogger, Any}"><code>ODEHybrid.tsl_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Plot all of the signals, grouped appropriately into figures. A custom x label can be added to figures as well</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/TimeSeriesLogger.jl#L241-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.vec_to_mat-Tuple{Any}" href="#ODEHybrid.vec_to_mat-Tuple{Any}"><code>ODEHybrid.vec_to_mat</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Helper function that converts a N-element vector with each element of length M into an N x M matrix </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/ODEHybrid.jl#L199-L201">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ODEHybrid.vector_to_state-Tuple{Any, Any}" href="#ODEHybrid.vector_to_state-Tuple{Any, Any}"><code>ODEHybrid.vector_to_state</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Build a state from a state vector by recursively moving through the  elements of a more complex example state (matrix, cell array, or struct), placing the relevant numerical values from the vector into the  appropriate places. This is used in odehybrid to convert a state vector into the original complex setup of states. The reverse function is state<em>to</em>vector.</p><p>state = vector<em>to</em>state(vector, state);</p><p>Inputs:</p><pre><code class="nohighlight hljs">vector  A vector containing the numerical values from the object
state   A numeric, cell array, or struct array type representing the
        sizes and types for the values in vector</code></pre><p>Outputs:</p><pre><code class="nohighlight hljs">state   A numeric, cell array, or struct array type
count   (Internal use only)</code></pre><p>Example:</p><pre><code class="nohighlight hljs">mutable struct TestStruc
    a
    bcd
end
Base.:(==)(a::TestStruc, b::TestStruc) = (Base.:(==)(a.a, b.a) &amp;&amp; Base.:(==)(a.bcd, b.bcd)) # Custom

x = [ [1 3; 4 2], TestStruc([5; 6], [7:9; 10]),  3.14 ]
v = state_to_vector(x)
x2 = vector_to_state(v, x)
x .== x2[1]</code></pre><p>See also: state<em>to</em>vector.</p><p>Online doc: http://www.anuncommonlab.com/doc/odehybrid/vector<em>to</em>state.html</p><p>Copyright 2014 An Uncommon Lab</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/benjjensen/ODEHybrid.jl/blob/b39309be49747f1a5a2d56eeef11b5f138255a3b/src/vector_to_state.jl#L3-L43">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Introduction</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Monday 31 January 2022 16:14">Monday 31 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
